<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Методы условной оптимизации</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
body { font-family: Arial, sans-serif; margin: 20px; background: #f8f9fa; }
.container { display: flex; flex-direction: column; gap: 25px; max-width: 1400px; margin: 0 auto; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
h1 { color: #2c3e50; margin: 0; }
select { padding: 8px 15px; font-size: 16px; border: 2px solid #3498db; border-radius: 4px; background: white; }
.plot-container { display: flex; gap: 30px; flex-wrap: wrap; }
#plot { width: 700px; height: 600px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
#table-container { flex: 1; min-width: 400px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 15px; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; }
th, td { border: 1px solid #ddd; padding: 10px; text-align: center; }
th { background-color: #3498db; color: white; font-weight: bold; }
tr:nth-child(even) { background-color: #f2f2f2; }
tr:hover { background-color: #e3f2fd; }
.loading { text-align: center; padding: 20px; color: #7f8c8d; font-style: italic; }
.footer { text-align: center; color: #7f8c8d; margin-top: 20px; font-size: 14px; }
.input-form { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px; display: none; }
.input-form.active { display: block; }
.form-group { margin-bottom: 12px; }
.form-group label { display: block; margin-bottom: 4px; font-weight: bold; color: #2c3e50; font-size: 14px; }
.form-group input { width: 100%; padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
.form-group input[type="submit"] { background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 4px; font-weight: bold; cursor: pointer; margin-top: 5px; }
.form-group input[type="submit"]:hover { background: #2980b9; }
.form-row { display: flex; gap: 12px; flex-wrap: wrap; }
.form-row > div { flex: 1; min-width: 180px; }
.badge { display: inline-block; background: #27ae60; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-left: 8px; }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Методы условной оптимизации <span class="badge">Live on GitHub</span></h1>
    <select id="methodSelect">
      <option value="penalty">1. Метод штрафных функций</option>
      <option value="barrier">2. Метод барьерных функций</option>
      <option value="combined">3. Комбинированный метод</option>
      <option value="multipliers">4. Метод множителей</option>
      <option value="exact_penalty">5. Метод точных штрафных функций</option>
      <option value="gradient_proj">6. Метод проекции градиента</option>
      <option value="zoutendijk">7. Метод Зойтендейка</option>
    </select>
  </div>

  <div id="inputForms">
    <div id="form_penalty" class="input-form">
      <h3>Параметры метода штрафных функций</h3>
      <form onsubmit="submitForm(event, 'penalty')">
        <div class="form-group"><label>f(x₁,x₂):</label><input type="text" name="f" value="x1^2 + x2^2"></div>
        <div class="form-group"><label>g(x₁,x₂) ≤ 0:</label><input type="text" name="g" value="x1 + x2 - 2"></div>
        <div class="form-row">
          <div class="form-group"><label>x₁⁰:</label><input type="number" name="x1_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>x₂⁰:</label><input type="number" name="x2_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>r₀:</label><input type="number" name="r0" value="1" step="0.1"></div>
          <div class="form-group"><label>C:</label><input type="number" name="C" value="10" step="0.1"></div>
          <div class="form-group"><label>Итерации:</label><input type="number" name="max_iter" value="6" min="1" max="20"></div>
        </div>
        <input type="submit" value="Выполнить метод штрафов">
      </form>
    </div>
    <div id="form_barrier" class="input-form">
      <h3>Параметры метода барьерных функций</h3>
      <form onsubmit="submitForm(event, 'barrier')">
        <div class="form-group"><label>f(x₁,x₂):</label><input type="text" name="f" value="x1^2 + x2^2"></div>
        <div class="form-group"><label>g(x₁,x₂) &lt; 0:</label><input type="text" name="g" value="x1 + x2 - 2"></div>
        <div class="form-row">
          <div class="form-group"><label>x₁⁰:</label><input type="number" name="x1_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>x₂⁰:</label><input type="number" name="x2_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>r₀:</label><input type="number" name="r0" value="1" step="0.1"></div>
          <div class="form-group"><label>C:</label><input type="number" name="C" value="4" step="0.1"></div>
          <div class="form-group"><label>Итерации:</label><input type="number" name="max_iter" value="6" min="1" max="20"></div>
        </div>
        <input type="submit" value="Выполнить барьерный метод">
      </form>
    </div>
    <div id="form_combined" class="input-form">
      <h3>Параметры комбинированного метода</h3>
      <form onsubmit="submitForm(event, 'combined')">
        <div class="form-group"><label>f(x₁,x₂):</label><input type="text" name="f" value="x1^2 + x2^2"></div>
        <div class="form-group"><label>g₁(x)=0:</label><input type="text" name="g1" value="x1 - 1"></div>
        <div class="form-group"><label>g₂(x)≤0:</label><input type="text" name="g2" value="x1 + x2 - 2"></div>
        <div class="form-row">
          <div class="form-group"><label>x₁⁰:</label><input type="number" name="x1_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>x₂⁰:</label><input type="number" name="x2_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>r₀:</label><input type="number" name="r0" value="1" step="0.1"></div>
          <div class="form-group"><label>C:</label><input type="number" name="C" value="4" step="0.1"></div>
          <div class="form-group"><label>Итерации:</label><input type="number" name="max_iter" value="5" min="1" max="20"></div>
        </div>
        <input type="submit" value="Выполнить комбинированный метод">
      </form>
    </div>
    <div id="form_multipliers" class="input-form">
      <h3>Параметры метода множителей</h3>
      <form onsubmit="submitForm(event, 'multipliers')">
        <div class="form-group"><label>f(x₁,x₂):</label><input type="text" name="f" value="x1^2 + x2^2"></div>
        <div class="form-group"><label>g(x₁,x₂) ≤ 0:</label><input type="text" name="g" value="x1 + x2 - 2"></div>
        <div class="form-row">
          <div class="form-group"><label>x₁⁰:</label><input type="number" name="x1_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>x₂⁰:</label><input type="number" name="x2_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>r₀:</label><input type="number" name="r0" value="1" step="0.1"></div>
          <div class="form-group"><label>C:</label><input type="number" name="C" value="4" step="0.1"></div>
          <div class="form-group"><label>μ₀:</label><input type="number" name="mu0" value="0" step="0.1"></div>
          <div class="form-group"><label>Итерации:</label><input type="number" name="max_iter" value="6" min="1" max="20"></div>
        </div>
        <input type="submit" value="Выполнить метод множителей">
      </form>
    </div>
    <div id="form_exact_penalty" class="input-form">
      <h3>Параметры метода точных штрафных функций</h3>
      <form onsubmit="submitForm(event, 'exact_penalty')">
        <div class="form-group"><label>f(x₁,x₂):</label><input type="text" name="f" value="x1^2 + x2^2"></div>
        <div class="form-group"><label>g(x₁,x₂) ≤ 0:</label><input type="text" name="g" value="x1 + x2 - 2"></div>
        <div class="form-row">
          <div class="form-group"><label>x₁⁰:</label><input type="number" name="x1_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>x₂⁰:</label><input type="number" name="x2_0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>r₀:</label><input type="number" name="r0" value="0.5" step="0.1"></div>
          <div class="form-group"><label>C:</label><input type="number" name="C" value="2" step="0.1"></div>
          <div class="form-group"><label>Итерации:</label><input type="number" name="max_iter" value="7" min="1" max="20"></div>
        </div>
        <input type="submit" value="Выполнить точный штраф">
      </form>
    </div>
    <div id="form_gradient_proj" class="input-form">
      <h3>Метод проекции градиента</h3>
      <form onsubmit="submitForm(event, 'gradient_proj')">
        <div class="form-group"><label>f(x₁,x₂):</label><input type="text" name="f" value="(x1-4)^2 + (x2-5)^2"></div>
        <div class="form-group"><label>g(x₁,x₂) ≤ 0:</label><input type="text" name="g" value="x1 + x2 - 1"></div>
        <div class="form-row">
          <div class="form-group"><label>x₁⁰:</label><input type="number" name="x1_0" value="0.7" step="0.1"></div>
          <div class="form-group"><label>x₂⁰:</label><input type="number" name="x2_0" value="0.3" step="0.1"></div>
          <div class="form-group"><label>Итерации:</label><input type="number" name="max_iter" value="15" min="1" max="50"></div>
        </div>
        <input type="submit" value="Выполнить проекцию градиента">
      </form>
    </div>
    <div id="form_zoutendijk" class="input-form">
      <h3>Метод Зойтендейка</h3>
      <form onsubmit="submitForm(event, 'zoutendijk')">
        <div class="form-group"><label>f(x₁,x₂):</label><input type="text" name="f" value="(x1-4)^2 + (x2-5)^2"></div>
        <div class="form-group"><label>g₁(x) ≤ 0:</label><input type="text" name="g1" value="x1 + x2 - 1"></div>
        <div class="form-group"><label>g₂(x) ≤ 0:</label><input type="text" name="g2" value="-x1"></div>
        <div class="form-group"><label>g₃(x) ≤ 0:</label><input type="text" name="g3" value="-x2"></div>
        <div class="form-row">
          <div class="form-group"><label>x₁⁰:</label><input type="number" name="x1_0" value="0" step="0.1"></div>
          <div class="form-group"><label>x₂⁰:</label><input type="number" name="x2_0" value="0.95" step="0.1"></div>
          <div class="form-group"><label>ε:</label><input type="number" name="epsilon" value="0.03" step="0.01"></div>
          <div class="form-group"><label>Итерации:</label><input type="number" name="max_iter" value="10" min="1" max="30"></div>
        </div>
        <input type="submit" value="Выполнить метод Зойтендейка">
      </form>
    </div>
  </div>

  <div class="plot-container">
    <div id="plot"></div>
    <div id="table-container">
      <div id="tableTitle" style="font-weight:bold; margin-bottom:10px;"></div>
      <div id="loading" class="loading">Выберите метод и нажмите "Выполнить"</div>
      <table id="resultsTable" style="display:none;">
        <thead id="tableHead"></thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

  <div class="footer">
    <p>Задача: минимизировать f(x) при ограничениях g(x) ≤ 0 (или = 0 для равенств)</p>
    <p>Все 7 методов работают в браузере. Можно также запустить C++ сервер в Visual Studio (localhost:8000).</p>
  </div>
</div>

<script>
// ----- Expression parser (x1, x2, +, -, *, /, ^, sin, cos, exp, log, sqrt) -----
function parseExpr(expr, x1, x2) {
  const s = expr.replace(/\s/g, '');
  let pos = 0;
  function skip() { while (pos < s.length && /[\s,]/.test(s[pos])) pos++; }
  function num() {
    skip();
    let start = pos;
    if (s[pos] === '-') pos++;
    while (pos < s.length && /[0-9.]/.test(s[pos])) pos++;
    if (start !== pos) return parseFloat(s.slice(start, pos)) || 0;
    return null;
  }
  function varX() {
    skip();
    if (s.substr(pos, 2) === 'x1') { pos += 2; return x1; }
    if (s.substr(pos, 2) === 'x2') { pos += 2; return x2; }
    if (s[pos] === 'x') { pos++; return x1; }
    return null;
  }
  function func() {
    skip();
    if (s.substr(pos, 3) === 'sin') { pos += 3; skip(); if (s[pos] === '(') pos++; const v = add(); if (s[pos] === ')') pos++; return Math.sin(v); }
    if (s.substr(pos, 3) === 'cos') { pos += 3; skip(); if (s[pos] === '(') pos++; const v = add(); if (s[pos] === ')') pos++; return Math.cos(v); }
    if (s.substr(pos, 3) === 'exp') { pos += 3; skip(); if (s[pos] === '(') pos++; const v = add(); if (s[pos] === ')') pos++; return Math.exp(v); }
    if (s.substr(pos, 3) === 'log') { pos += 3; skip(); if (s[pos] === '(') pos++; const v = add(); if (s[pos] === ')') pos++; return Math.log(Math.max(v, 1e-10)); }
    if (s.substr(pos, 4) === 'sqrt') { pos += 4; skip(); if (s[pos] === '(') pos++; const v = add(); if (s[pos] === ')') pos++; return Math.sqrt(Math.max(v, 0)); }
    return null;
  }
  function factor() {
    skip();
    if (s[pos] === '(') { pos++; const v = add(); if (s[pos] === ')') pos++; return v; }
    if (s[pos] === '-') { pos++; return -factor(); }
    const n = num(); if (n !== null) return n;
    const v = varX(); if (v !== null) return v;
    const f = func(); if (f !== null) return f;
    return 0;
  }
  function pow() {
    let left = factor();
    skip();
    if (s[pos] === '^') { pos++; const right = pow(); left = Math.pow(left, right); }
    return left;
  }
  function term() {
    let left = pow();
    for (;;) {
      skip();
      if (s[pos] === '*') { pos++; left *= term(); }
      else if (s[pos] === '/') { pos++; left /= term(); }
      else break;
    }
    return left;
  }
  function add() {
    let left = term();
    for (;;) {
      skip();
      if (s[pos] === '+') { pos++; left += term(); }
      else if (s[pos] === '-') { pos++; left -= term(); }
      else break;
    }
    return left;
  }
  return add();
}

// ----- In-browser: Penalty 2D -----
function runPenaltyJS(params) {
  const f_expr = params.get('f') || 'x1^2 + x2^2';
  const g_expr = params.get('g') || 'x1 + x2 - 2';
  let x1 = parseFloat(params.get('x1_0')) || 0.5, x2 = parseFloat(params.get('x2_0')) || 0.5;
  let r = parseFloat(params.get('r0')) || 1, C = parseFloat(params.get('C')) || 10;
  const N = Math.min(Math.max(parseInt(params.get('max_iter'), 10) || 6, 1), 20);
  const f = (a, b) => parseExpr(f_expr, a, b);
  const g = (a, b) => parseExpr(g_expr, a, b);
  const F = (a, b, rr) => {
    const gv = g(a, b);
    return f(a, b) + 0.5 * rr * Math.pow(Math.max(0, gv), 2);
  };
  const h = 1e-6;
  const gradF = (a, b, rr) => [
    (F(a + h, b, rr) - F(a - h, b, rr)) / (2 * h),
    (F(a, b + h, rr) - F(a, b - h, rr)) / (2 * h)
  ];
  const minimize = (a, b, rr) => {
    for (let it = 0; it < 5000; it++) {
      const [gx1, gx2] = gradF(a, b, rr);
      let t = 1;
      const f0 = F(a, b, rr);
      let na, nb;
      for (;;) {
        na = a - t * gx1; nb = b - t * gx2;
        if (F(na, nb, rr) < f0) break;
        t *= 0.5;
        if (t < 1e-10) return [a, b];
      }
      if (Math.hypot(na - a, nb - b) < 1e-6) return [na, nb];
      a = na; b = nb;
    }
    return [a, b];
  };
  let csv = 'method,k,r,x1,x2,g,F\n';
  for (let k = 0; k < N; k++) {
    [x1, x2] = minimize(x1, x2, r);
    const Fval = F(x1, x2, r), gv = g(x1, x2);
    csv += `penalty,${k},${r},${x1},${x2},${gv},${Fval}\n`;
    r *= C;
  }
  return csv;
}

// ----- In-browser: Barrier 2D -----
function runBarrierJS(params) {
  const f_expr = params.get('f') || 'x1^2 + x2^2';
  const g_expr = params.get('g') || 'x1 + x2 - 2';
  let x1 = parseFloat(params.get('x1_0')) || 0.5, x2 = parseFloat(params.get('x2_0')) || 0.5;
  let r = parseFloat(params.get('r0')) || 1, C = parseFloat(params.get('C')) || 4;
  const N = Math.min(Math.max(parseInt(params.get('max_iter'), 10) || 6, 1), 20);
  const f = (a, b) => parseExpr(f_expr, a, b);
  const g = (a, b) => parseExpr(g_expr, a, b);
  if (g(x1, x2) >= 0) { x1 = 0.5; x2 = 0.5; }
  const F = (a, b, rr) => {
    const gv = g(a, b);
    if (gv >= -1e-8) return 1e20;
    return f(a, b) - rr / gv;
  };
  const h = 1e-6;
  const gradF = (a, b, rr) => [
    (F(a + h, b, rr) - F(a - h, b, rr)) / (2 * h),
    (F(a, b + h, rr) - F(a, b - h, rr)) / (2 * h)
  ];
  const minimize = (a, b, rr) => {
    for (let it = 0; it < 5000; it++) {
      const [gx1, gx2] = gradF(a, b, rr);
      let t = 1;
      const f0 = F(a, b, rr);
      let na, nb;
      for (;;) {
        na = a - t * gx1; nb = b - t * gx2;
        if (F(na, nb, rr) < f0) break;
        t *= 0.5;
        if (t < 1e-10) return [a, b];
      }
      if (Math.hypot(na - a, nb - b) < 1e-6) return [na, nb];
      a = na; b = nb;
    }
    return [a, b];
  };
  let csv = 'method,k,r,x1,x2,g,F\n';
  for (let k = 0; k < N; k++) {
    [x1, x2] = minimize(x1, x2, r);
    const Fval = F(x1, x2, r), gv = g(x1, x2);
    csv += `barrier,${k},${r},${x1},${x2},${gv},${Fval}\n`;
    r /= C;
  }
  return csv;
}

// ----- In-browser: Exact Penalty 2D -----
function runExactPenaltyJS(params) {
  const f_expr = params.get('f') || 'x1^2 + x2^2';
  const g_expr = params.get('g') || 'x1 + x2 - 2';
  let x1 = parseFloat(params.get('x1_0')) || 0.5, x2 = parseFloat(params.get('x2_0')) || 0.5;
  let r = parseFloat(params.get('r0')) || 0.5, C = parseFloat(params.get('C')) || 2;
  const N = Math.min(Math.max(parseInt(params.get('max_iter'), 10) || 7, 1), 20);
  const f = (a, b) => parseExpr(f_expr, a, b);
  const g = (a, b) => parseExpr(g_expr, a, b);
  const F = (a, b, rr) => f(a, b) + rr * Math.max(0, g(a, b));
  const h = 1e-6;
  const gradF = (a, b, rr) => [
    (F(a + h, b, rr) - F(a - h, b, rr)) / (2 * h),
    (F(a, b + h, rr) - F(a, b - h, rr)) / (2 * h)
  ];
  const minimize = (a, b, rr) => {
    for (let it = 0; it < 5000; it++) {
      const [gx1, gx2] = gradF(a, b, rr);
      let t = 1, f0 = F(a, b, rr);
      let na, nb;
      for (;;) {
        na = a - t * gx1; nb = b - t * gx2;
        if (F(na, nb, rr) < f0) break;
        t *= 0.5;
        if (t < 1e-10) return [a, b];
      }
      if (Math.hypot(na - a, nb - b) < 1e-6) return [na, nb];
      a = na; b = nb;
    }
    return [a, b];
  };
  let csv = 'method,k,r,x1,x2,g,F\n';
  for (let k = 0; k < N; k++) {
    [x1, x2] = minimize(x1, x2, r);
    csv += `exact_penalty,${k},${r},${x1},${x2},${g(x1, x2)},${F(x1, x2, r)}\n`;
    r *= C;
  }
  return csv;
}

// ----- In-browser: Combined (equality g1=0 + inequality g2<0) -----
function runCombinedJS(params) {
  const f_expr = params.get('f') || 'x1^2 + x2^2';
  const g1_expr = params.get('g1') || 'x1 - 1';
  const g2_expr = params.get('g2') || 'x1 + x2 - 2';
  let x1 = parseFloat(params.get('x1_0')) || 0.5, x2 = parseFloat(params.get('x2_0')) || 0.5;
  let r = parseFloat(params.get('r0')) || 1, C = parseFloat(params.get('C')) || 4;
  const N = Math.min(Math.max(parseInt(params.get('max_iter'), 10) || 5, 1), 20);
  const f = (a, b) => parseExpr(f_expr, a, b);
  const g1 = (a, b) => parseExpr(g1_expr, a, b);
  const g2 = (a, b) => parseExpr(g2_expr, a, b);
  if (g2(x1, x2) >= 0) { x1 = 0.5; x2 = 0.5; }
  const F = (a, b, rr) => {
    const eq = g1(a, b), ineq = g2(a, b);
    if (ineq >= 0) return 1e20;
    return f(a, b) + 0.5 * eq * eq / rr - rr * Math.log(-ineq);
  };
  const h = 1e-6;
  const minimize = (a, b, rr) => {
    for (let it = 0; it < 5000; it++) {
      const gx1 = (F(a + h, b, rr) - F(a - h, b, rr)) / (2 * h);
      const gx2 = (F(a, b + h, rr) - F(a, b - h, rr)) / (2 * h);
      let t = 1, f0 = F(a, b, rr);
      let na, nb;
      for (;;) {
        na = a - t * gx1; nb = b - t * gx2;
        if (g2(na, nb) < 0 && F(na, nb, rr) < f0) break;
        t *= 0.5;
        if (t < 1e-10) return [a, b];
      }
      if (Math.hypot(na - a, nb - b) < 1e-6) return [na, nb];
      a = na; b = nb;
    }
    return [a, b];
  };
  let csv = 'method,k,r,x1,x2,g1,g2,F\n';
  for (let k = 0; k < N; k++) {
    [x1, x2] = minimize(x1, x2, r);
    csv += `combined,${k},${r},${x1},${x2},${g1(x1, x2)},${g2(x1, x2)},${F(x1, x2, r)}\n`;
    r /= C;
  }
  return csv;
}

// ----- In-browser: Multipliers 2D -----
function runMultipliersJS(params) {
  const f_expr = params.get('f') || 'x1^2 + x2^2';
  const g_expr = params.get('g') || 'x1 + x2 - 2';
  let x1 = parseFloat(params.get('x1_0')) || 0.5, x2 = parseFloat(params.get('x2_0')) || 0.5;
  let r = parseFloat(params.get('r0')) || 1, C = parseFloat(params.get('C')) || 4;
  let mu = parseFloat(params.get('mu0')) || 0;
  const N = Math.min(Math.max(parseInt(params.get('max_iter'), 10) || 6, 1), 20);
  const f = (a, b) => parseExpr(f_expr, a, b);
  const g = (a, b) => parseExpr(g_expr, a, b);
  const L = (a, b, rr) => {
    const gv = g(a, b);
    const term = Math.max(0, mu + rr * gv);
    return f(a, b) + (term * term - mu * mu) / (2 * rr);
  };
  const h = 1e-6;
  const gradL = (a, b, rr) => [
    (L(a + h, b, rr) - L(a - h, b, rr)) / (2 * h),
    (L(a, b + h, rr) - L(a, b - h, rr)) / (2 * h)
  ];
  const minimize = (a, b, rr) => {
    for (let it = 0; it < 5000; it++) {
      const [gx1, gx2] = gradL(a, b, rr);
      let t = 1, f0 = L(a, b, rr);
      let na, nb;
      for (;;) {
        na = a - t * gx1; nb = b - t * gx2;
        if (L(na, nb, rr) < f0) break;
        t *= 0.5;
        if (t < 1e-10) return [a, b];
      }
      if (Math.hypot(na - a, nb - b) < 1e-6) return [na, nb];
      a = na; b = nb;
    }
    return [a, b];
  };
  let csv = 'method,k,r,x1,x2,g,F,mu\n';
  for (let k = 0; k < N; k++) {
    [x1, x2] = minimize(x1, x2, r);
    const gv = g(x1, x2);
    csv += `multipliers,${k},${r},${x1},${x2},${gv},${L(x1, x2, r)},${mu}\n`;
    mu = Math.max(0, mu + r * gv);
    r *= C;
  }
  return csv;
}

// ----- In-browser: Gradient Projection 2D -----
function runGradientProjJS(params) {
  const f_expr = params.get('f') || '(x1-4)^2 + (x2-5)^2';
  const g_expr = params.get('g') || 'x1 + x2 - 1';
  let x1 = parseFloat(params.get('x1_0')) || 0.7, x2 = parseFloat(params.get('x2_0')) || 0.3;
  const N = Math.min(Math.max(parseInt(params.get('max_iter'), 10) || 15, 1), 30);
  const f = (a, b) => parseExpr(f_expr, a, b);
  const g = (a, b) => parseExpr(g_expr, a, b);
  const h = 1e-6;
  const getA = (a, b) => [
    (g(a + h, b) - g(a - h, b)) / (2 * h),
    (g(a, b + h) - g(a, b - h)) / (2 * h)
  ];
  const projectGrad = (a, b, df1, df2) => {
    const [a1, a2] = getA(a, b);
    const denom = a1 * a1 + a2 * a2 + 1e-12;
    const coef = (a1 * df1 + a2 * df2) / denom;
    return [df1 - coef * a1, df2 - coef * a2];
  };
  const correction = (a, b) => {
    const [a1, a2] = getA(a, b);
    const denom = a1 * a1 + a2 * a2 + 1e-12;
    const tau = -g(a, b);
    const lam = tau / denom;
    return [a1 * lam, a2 * lam];
  };
  const lineSearch = (a, b, d1, d2) => {
    let alpha = 1;
    const f0 = f(a, b);
    for (let i = 0; i < 20; i++) {
      if (f(a + alpha * d1, b + alpha * d2) < f0) return alpha;
      alpha *= 0.5;
    }
    return 0;
  };
  let csv = 'method,k,x1,x2,g,fx\n';
  for (let k = 0; k < N; k++) {
    const df1 = (f(x1 + h, x2) - f(x1 - h, x2)) / (2 * h);
    const df2 = (f(x1, x2 + h) - f(x1, x2 - h)) / (2 * h);
    const [pd1, pd2] = projectGrad(x1, x2, df1, df2);
    const d1 = -pd1, d2 = -pd2;
    const t = lineSearch(x1, x2, d1, d2);
    const [c1, c2] = correction(x1 + t * d1, x2 + t * d2);
    x1 = x1 + t * d1 + c1;
    x2 = x2 + t * d2 + c2;
    csv += `gradient_proj,${k},${x1},${x2},${g(x1, x2)},${f(x1, x2)}\n`;
    if (Math.hypot(c1, c2) < 1e-6 && Math.hypot(pd1, pd2) < 1e-6) break;
  }
  return csv;
}

// ----- In-browser: Zoutendijk 2D -----
function runZoutendijkJS(params) {
  const f_expr = params.get('f') || '(x1-4)^2 + (x2-5)^2';
  const g1_expr = params.get('g1') || 'x1 + x2 - 1';
  const g2_expr = params.get('g2') || '-x1';
  const g3_expr = params.get('g3') || '-x2';
  let x1 = parseFloat(params.get('x1_0')) || 0, x2 = parseFloat(params.get('x2_0')) || 0.95;
  let eps = parseFloat(params.get('epsilon')) || 0.03;
  const N = Math.min(Math.max(parseInt(params.get('max_iter'), 10) || 10, 1), 30);
  const f = (a, b) => parseExpr(f_expr, a, b);
  const g1 = (a, b) => parseExpr(g1_expr, a, b);
  const g2 = (a, b) => parseExpr(g2_expr, a, b);
  const g3 = (a, b) => parseExpr(g3_expr, a, b);
  const constraints = [g1, g2, g3];
  const grad = (func, a, b) => [
    (func(a + 1e-6, b) - func(a - 1e-6, b)) / 2e-6,
    (func(a, b + 1e-6) - func(a, b - 1e-6)) / 2e-6
  ];
  const findDirection = (active) => {
    const [df1, df2] = grad(f, x1, x2);
    const activeGrads = active.map(j => grad(constraints[j], x1, x2));
    if (active.length === 0) {
      const norm = Math.hypot(df1, df2);
      if (norm > 1e-12) return { d1: -df1 / norm, d2: -df2 / norm, z: df1 * (-df1 / norm) + df2 * (-df2 / norm) };
      return { d1: 0, d2: 0, z: 0 };
    }
    let bestZ = 1e20, bestD1 = 0, bestD2 = 0;
    for (let i = 0; i < 200; i++) {
      const angle = 2 * Math.PI * i / 200;
      const td1 = Math.cos(angle), td2 = Math.sin(angle);
      let z = df1 * td1 + df2 * td2;
      activeGrads.forEach(([ag1, ag2]) => { z = Math.max(z, ag1 * td1 + ag2 * td2); });
      if (z < bestZ) { bestZ = z; bestD1 = td1; bestD2 = td2; }
    }
    return { d1: bestD1, d2: bestD2, z: bestZ };
  };
  const lineSearch = (d1, d2, tMax) => {
    const f0 = f(x1, x2);
    for (let iter = 0; iter < 20; iter++) {
      const tt = tMax * Math.pow(0.7, iter);
      const nx1 = x1 + tt * d1, nx2 = x2 + tt * d2;
      if (constraints.every(c => c(nx1, nx2) <= 1e-6) && f(nx1, nx2) < f0) return tt;
    }
    return 0;
  };
  let csv = 'method,k,x1,x2,z,fx,g1,g2,g3\n';
  let wrote = false;
  for (let k = 0; k < N; k++) {
    const gvals = [g1(x1, x2), g2(x1, x2), g3(x1, x2)];
    const active = gvals.map((v, j) => v >= -eps ? j : -1).filter(j => j >= 0);
    const { d1, d2, z } = findDirection(active);
    if (z >= -eps) {
      csv += `zoutendijk,${k},${x1},${x2},${z},${f(x1, x2)},${gvals[0]},${gvals[1]},${gvals[2]}\n`;
      wrote = true;
      break;
    }
    let tMax = 1e6;
    for (let j = 0; j < 3; j++) {
      if (gvals[j] >= -eps) continue;
      const [dg1, dg2] = grad(constraints[j], x1, x2);
      const deriv = dg1 * d1 + dg2 * d2;
      if (deriv < 0) {
        const tj = -gvals[j] / deriv;
        if (tj < tMax) tMax = tj;
      }
    }
    tMax = Math.min(tMax, 10);
    const t = lineSearch(d1, d2, tMax);
    if (t <= 1e-12) break;
    x1 += t * d1;
    x2 += t * d2;
    const gv1 = g1(x1, x2), gv2 = g2(x1, x2), gv3 = g3(x1, x2);
    csv += `zoutendijk,${k},${x1},${x2},${z},${f(x1, x2)},${gv1},${gv2},${gv3}\n`;
    wrote = true;
    eps *= 0.9;
    if (eps < 1e-8) eps = 1e-8;
  }
  if (!wrote) {
    const gv1 = g1(x1, x2), gv2 = g2(x1, x2), gv3 = g3(x1, x2);
    csv += `zoutendijk,0,${x1},${x2},0,${f(x1, x2)},${gv1},${gv2},${gv3}\n`;
  }
  return csv;
}

function runInBrowser(method, formData) {
  if (method === 'penalty') return runPenaltyJS(formData);
  if (method === 'barrier') return runBarrierJS(formData);
  if (method === 'exact_penalty') return runExactPenaltyJS(formData);
  if (method === 'combined') return runCombinedJS(formData);
  if (method === 'multipliers') return runMultipliersJS(formData);
  if (method === 'gradient_proj') return runGradientProjJS(formData);
  if (method === 'zoutendijk') return runZoutendijkJS(formData);
  return 'method,k,error\n' + method + ',0,Unknown method\n';
}

const methodInfo = {
  penalty: { title: "1. Метод штрафных функций" },
  barrier: { title: "2. Метод барьерных функций" },
  combined: { title: "3. Комбинированный метод" },
  multipliers: { title: "4. Метод множителей" },
  exact_penalty: { title: "5. Метод точных штрафных функций" },
  gradient_proj: { title: "6. Метод проекции градиента" },
  zoutendijk: { title: "7. Метод Зойтендейка" }
};

function getCurrentMethod() {
  return (new URLSearchParams(window.location.search)).get('method') || 'penalty';
}

document.getElementById('methodSelect').addEventListener('change', function() {
  window.location.search = '?method=' + this.value;
});

function initUI(method) {
  document.getElementById('methodSelect').value = method;
  const info = methodInfo[method] || methodInfo.penalty;
  document.getElementById('tableTitle').textContent = info.title;
  document.querySelectorAll('.input-form').forEach(f => f.classList.remove('active'));
  const form = document.getElementById('form_' + method);
  if (form) form.classList.add('active');
  document.getElementById('loading').style.display = 'block';
  document.getElementById('resultsTable').style.display = 'none';
}

async function submitForm(event, method) {
  event.preventDefault();
  const formData = new FormData(event.target);
  formData.append('method', method);
  document.getElementById('loading').textContent = 'Вычисление...';
  document.getElementById('loading').style.display = 'block';
  document.getElementById('resultsTable').style.display = 'none';

  try {
    const response = await fetch('results.csv', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams(formData).toString()
    });
    if (response.ok) {
      const text = await response.text();
      if (text && text.trim().length >= 10) {
        displayResults(method, text);
        return;
      }
    }
  } catch (e) {}
  const csv = runInBrowser(method, formData);
  displayResults(method, csv);
}

function displayResults(method, csvText) {
  const rows = csvText.trim().split('\n');
  if (rows.length < 2) {
    document.getElementById('loading').textContent = 'Неверный формат CSV';
    return;
  }
  const headers = rows[0].split(',');
  document.getElementById('tableHead').innerHTML = '<tr>' + headers.slice(1).map(h => `<th>${h}</th>`).join('') + '</tr>';
  const tableBody = document.getElementById('tableBody');
  tableBody.innerHTML = '';
  const plotData = { xs: [], ys: [], zs: [], ks: [] };
  let is2D = false;
  for (let i = 1; i < rows.length; i++) {
    const cols = rows[i].split(',');
    if (cols[0] !== method) continue;
    let rowHtml = '<tr>';
    for (let j = 1; j < cols.length; j++) {
      const val = parseFloat(cols[j]);
      rowHtml += `<td>${isNaN(val) ? cols[j] : val.toFixed(6)}</td>`;
    }
    tableBody.innerHTML += rowHtml;
    plotData.ks.push(parseFloat(cols[1]));
    const hasX1 = headers.includes('x1'), hasX2 = headers.includes('x2');
    is2D = is2D || (hasX1 && hasX2);
    if (hasX1 && hasX2) {
      const x1_idx = headers.indexOf('x1'), x2_idx = headers.indexOf('x2');
      const F_idx = headers.indexOf('F') >= 0 ? headers.indexOf('F') : headers.indexOf('fx');
      if (x1_idx >= 0 && x2_idx >= 0 && F_idx >= 0) {
        plotData.xs.push(parseFloat(cols[x1_idx]));
        plotData.ys.push(parseFloat(cols[x2_idx]));
        plotData.zs.push(parseFloat(cols[F_idx]));
      }
    } else {
      const x_idx = headers.indexOf('x');
      const F_idx = headers.indexOf('F') >= 0 ? headers.indexOf('F') : headers.indexOf('fx');
      if (x_idx >= 0 && F_idx >= 0) {
        plotData.xs.push(parseFloat(cols[x_idx]));
        plotData.zs.push(parseFloat(cols[F_idx]));
      }
    }
  }
  document.getElementById('loading').style.display = 'none';
  document.getElementById('resultsTable').style.display = 'table';
  renderPlot(method, plotData, is2D);
}

function renderPlot(method, data, is2D) {
  const plotDiv = document.getElementById('plot');
  let traces = [];
  let layout = { scene: { xaxis: { title: "x1" }, yaxis: { title: "x2" }, zaxis: { title: "f(x)" }, camera: { eye: { x: 1.8, y: 1.8, z: 1.2 } } }, margin: { r: 50, l: 50, b: 50, t: 50 }, height: 600, width: 700 };
  const isGradOrZout = (method === 'gradient_proj' || method === 'zoutendijk');
  if (is2D && data.xs.length > 0) {
    const X = [], Y = [], Z = [];
    const xMin = isGradOrZout ? -1 : -1, xMax = isGradOrZout ? 5 : 2, yMin = -1, yMax = isGradOrZout ? 5 : 2;
    const step = isGradOrZout ? 0.2 : 0.1;
    const surf = (a, b) => isGradOrZout ? (a - 4) * (a - 4) + (b - 5) * (b - 5) : a * a + b * b;
    for (let x = xMin; x <= xMax; x += step) {
      const rx = [], ry = [], rz = [];
      for (let y = yMin; y <= yMax; y += step) {
        rx.push(x); ry.push(y); rz.push(surf(x, y));
      }
      X.push(rx); Y.push(ry); Z.push(rz);
    }
    traces.push({ type: "surface", x: X, y: Y, z: Z, colorscale: "Blues", opacity: 0.85, name: "f(x1,x2)" });
    const xc = [], yc = [], zc = [];
    const lineY = isGradOrZout ? (x => 1 - x) : (x => 2 - x);
    for (let x = xMin; x <= xMax; x += 0.05) {
      const y = lineY(x);
      if (y >= yMin && y <= yMax) { xc.push(x); yc.push(y); zc.push(surf(x, y)); }
    }
    traces.push({ type: "scatter3d", x: xc, y: yc, z: zc, mode: "lines", line: { color: "orange", width: 4 }, name: "Constraint" });
    traces.push({ type: "scatter3d", x: data.xs, y: data.ys, z: data.zs, mode: "lines+markers", marker: { size: 5, color: "black" }, line: { width: 4, color: "darkblue" }, name: "Iterations" });
    const ex = isGradOrZout ? 0 : 1, ey = isGradOrZout ? 1 : 1, ez = isGradOrZout ? 17 : 2;
    traces.push({ type: "scatter3d", x: [ex], y: [ey], z: [ez], mode: "markers+text", marker: { size: 10, color: "red" }, text: [isGradOrZout ? "Exact (0,1)" : "Exact (1,1)"], textposition: "top center", name: "Exact" });
  } else {
    traces.push({ type: "scatter", x: data.ks, y: data.zs.length ? data.zs : data.xs, mode: "lines+markers", name: "Iterations" });
    layout = { xaxis: { title: "k" }, yaxis: { title: "value" }, height: 600, width: 700 };
  }
  Plotly.newPlot(plotDiv, traces, layout, { responsive: true });
}

window.addEventListener('DOMContentLoaded', () => {
  const method = getCurrentMethod();
  initUI(method);
  setTimeout(() => {
    const form = document.querySelector('#form_' + method + ' form');
    if (form) form.requestSubmit();
  }, 300);
});
</script>
</body>
</html>
